# Описание процесса работы над заданием

В этом файле я опишу ход своих мыслей, процесс разработки и все вопросы, которые возникли при выполнении тестового задания.

### Требования

Первое - анализ требований.

Данные для решения задачи я получил из двух источников:

1. Ссылка на задачу - [notion](https://fundraiseup.notion.site/Frontend-test-dba2aced238f42318ca7e3982e23f84a)
2. Примечание от HR - не переусложнять и сделать ровно то, что требуется по задаче.

### Проектирование (Время: 2ч)

При прочтении постановки я осознанно не стал читать бонус-трек по причине того, что он может стать проверкой архитектурного решения и выступать следующей итерацией развития приложения после основгого трека.

Разделение бизнес-логики для меня - ключевое требование на этапе проектирования и оно сразу ограничело список архитектурных паттернов: DDD, Гексагональная архитектура и тд (всё, что имеет разделение приложения на слои). Но остались некоторые нюансы, которые нужно было обдумать:

- Сколько мне нужно слоев (в классическом DDD их, как минимум, 3 - доменная логика, инфраструктура, отображение)
- Насколько эти слои должны быть гибкими и независимыми (coupling/cohesion)
- Что из SOLID мне нужно исходя из требований и выбранного архитектурного паттерна
- Нужна ли мне модульность

Немного поразмыслив, я сделал небольшой прототип с несколькими модулями системы, разбив каждый на слои.
Это было что-то вроде:

```
- modules
  - exercise
    - domain
      - entity
      - use-case
      - ports
    - infrastructure
      - repository
    - presentation
      - components
      - hooks
  - word
    - domain
      - entity
      - use-case
      - ports
    - infrastructure
      - repository
    - presentation
      - components
      - hooks
app.ts
```

Такое решение было довольно внушительным на мой взгляд. Exercise принимал generic в качестве типа предмета тренировки (в моем случае это были английские слова, но могло быть что угондо) и, с помощью use-case, управлял логикой самого упражнения. Через репозитории я сохранял данные в localStorage (в последствии можно было добавить репозитории для сохранения данных на бэк или сбора статистики в GA). Все слои и модули взаимодействовали через интерфейс, таким образом я получал Dependency Inversion и моя бизнес-логика была полностью защищена от сайд-эффектов.
Но это было довольно громоздко, сложно читать без предварительного погружения и долго.
И, кажется, это подходило под пункт переусложнения.

В итоге я решил найти компромисс.

Теперь архитектура выглядит так:

```
- domain
- infrastructure
- presentation
  - components
  - services
app.ts
```

_domain_ - вся бизнес-логика приложения находится в классах с методами, все поля защищены приватностью

_infrastructure_ - логика получения списка слов для тренировки. В этом слое можно делать трансформацию слов (toLowerCase, toUpperCase, filter и тд)

_presentation_ - отображение. Компоненты и сервисы, которые необходимы на уровне отображения. Любой компонент можно заменить с DOM API, например, на canvas

На этом я решил остановиться и перейти к разработке каждого слоя

### Domain (Время: 1,5ч)

В процессе работы над этим слоев возникло несколько вопросов:

1. Могут ли слова повторяться в тренировке
2. Сколько может быть слов максимум в будущем
3. Сколько может быть максимум слов в тренировке

Эти вопросы влияли на выбор алгоритмы формирования пула занятия, т.к. если

1. Слова могут повторяться, то я не могу предварительно подготавливать массив с случайными словами из общего списка слов и будет проще каждый раз вытаскивать случайное слово из общего списка (или дублировать слова заранее в общем списке слов)
2. Слов может быть очень много, то я так же не могу заранее подготавливать массив случайных слов для урока на основе сортировки - это может занять слишком много времени
3. Если слов в тренировке может быть очень много, то алгоритм вытаскивания случайного слова тоже может занять много времени

На данный момент все ответы получены из размера текущего списка слов и тренировки

### Infrastructure (Время: 10м)

На этом слое не было вопросов и здесь всего 1 репозиторий с одним методом получения списка слов в соответсвии с интерфейсом из domain

### Presentation (6ч)

Вот тут вопросов было много. По порядку:

#### Компоненты

Задача: изолировать логику отображения
Решение: HTML компоненты, которые могут создавать ноды и обрабатывать события на них

#### Обмен данными между компонентами

Первый мой подход был через создания CustomEvent и его отправку/получение. И это работало прекрасно, кроме того, что от подписок нужно было избавляться при ре-рендеринге компонента. Это делало код крайне хрупким и сложно читаемым. Пришлось от этого отказаться

Текущий подход - колбеки. Максимально надежно и просто, но некоторые компоненты ре-рендерятся чаще, чем нужно (в отсутвтие алгоритма Reconciliation).

#### Отписка от событий

Отказ от CustomEvent не исключил полностью проблему в отиской от событий при ре-рендеринге, т.к. события click не исключить. Приходится отписываться от этих собитий вручную после завершения упражнения.

### Бонус-трек =)

Бонус-трек внес свои коррективы в реализацию и добавил дополнительные подписки на события и триггеры для отписок от click и тд. К тому же в state window.history я изначально сохранял номер упражнения, что оказалось не целесообразно и стал сохранять состояние текущей группы упражнений.

### Спасибо за задание, было интересно!
